# Allow interpreting '>=' and '>>=' as part of a template in code like
# 'void f(list<list<B>>=val);'. If true, 'assert(x<0 && y>=3)' will be broken.
# Improvements to template detection may make this option obsolete.
tok_split_gte                   = false    # true/false

# If the file contains bytes with values between 128 and 255, but is not
# UTF-8, then output as UTF-8.
utf8_byte                       = false    # true/false

# Force the output encoding to UTF-8.
utf8_force                      = false    # true/false

# Whether to balance spaces inside nested parentheses.
sp_balance_nested_parens        = false    # true/false

# Add or remove space before ';'.
#
# Default: remove
sp_before_semi                  = ignore   # ignore/add/remove/force

# Add or remove space after ';', except when followed by a comment.
#
# Default: add
sp_after_semi                   = ignore   # ignore/add/remove/force

# Add or remove space after ';' in non-empty 'for' statements.
#
# Default: force
sp_after_semi_for               = ignore   # ignore/add/remove/force

# Add or remove space before ','.
#
# Default: remove
sp_before_comma                 = ignore   # ignore/add/remove/force

# Add or remove space before case ':'.
#
# Default: remove
sp_before_case_colon            = ignore   # ignore/add/remove/force

# Add or remove space after the '!' (not) unary operator.
#
# Default: remove
sp_not                          = ignore   # ignore/add/remove/force

# Add or remove space after the '~' (invert) unary operator.
#
# Default: remove
sp_inv                          = ignore   # ignore/add/remove/force

# Add or remove space after the '&' (address-of) unary operator. This does not
# affect the spacing after a '&' that is part of a type.
#
# Default: remove
sp_addr                         = ignore   # ignore/add/remove/force

# Add or remove space around the '.' or '->' operators.
#
# Default: remove
sp_member                       = ignore   # ignore/add/remove/force

# Add or remove space after the '*' (dereference) unary operator. This does
# not affect the spacing after a '*' that is part of a type.
#
# Default: remove
sp_deref                        = ignore   # ignore/add/remove/force

# Add or remove space after '+' or '-', as in 'x = -5' or 'y = +7'.
#
# Default: remove
sp_sign                         = ignore   # ignore/add/remove/force

# Add or remove space between '++' and '--' the word to which it is being
# applied, as in '(--x)' or 'y++;'.
#
# Default: remove
sp_incdec                       = ignore   # ignore/add/remove/force

# Add or remove space before a backslash-newline at the end of a line.
#
# Default: add
sp_before_nl_cont               = ignore   # ignore/add/remove/force

#
# Indenting options
#

# The number of columns to indent per level. Usually 2, 3, 4, or 8.
#
# Default: 8
indent_columns                  = 2

# How to use tabs when indenting code.
#
# 0: Spaces only
# 1: Indent with tabs to brace level, align with spaces (default)
# 2: Indent and align with tabs, using spaces when not on a tabstop
#
# Default: 1
indent_with_tabs                = 0        # unsigned number

# Whether to indent comments that are not at a brace level with tabs on a
# tabstop. Requires indent_with_tabs=2. If false, will use spaces.
indent_cmt_with_tabs            = false    # true/false

# Whether to indent strings broken by '\' so that they line up.
indent_align_string             = false    # true/false

# Whether braces are indented to the body level.
indent_braces                   = false    # true/false

# Whether to disable indenting function braces if indent_braces=true.
indent_braces_no_func           = false    # true/false

# Whether to disable indenting class braces if indent_braces=true.
indent_braces_no_class          = false    # true/false

# Whether to disable indenting struct braces if indent_braces=true.
indent_braces_no_struct         = false    # true/false

# Whether to indent based on the size of the brace parent,
# i.e. 'if' => 3 spaces, 'for' => 4 spaces, etc.
indent_brace_parent             = false    # true/false

# Whether to indent the body of a 'namespace'.
indent_namespace                = true     # true/false

# Whether the 'extern "C"' body is indented.
indent_extern                   = true     # true/false

# Whether the 'class' body is indented.
indent_class                    = true     # true/false

# Whether to indent the stuff after a leading base class colon.
indent_class_colon              = true     # true/false

# Whether to indent 'if' following 'else' as a new block under the 'else'.
# If false, 'else\nif' is treated as 'else if' for indenting purposes.
indent_else_if                  = false    # true/false

# Whether to indent continued variable declarations instead of aligning.
indent_var_def_cont             = false    # true/false

# Whether to indent continued function call parameters one indent level,
# rather than aligning parameters under the open parenthesis.
indent_func_call_param          = false    # true/false

# Whether to indent continued function definition parameters one indent level,
# rather than aligning parameters under the open parenthesis.
indent_func_def_param           = false    # true/false

# Whether to indent continued function call prototype one indent level,
# rather than aligning parameters under the open parenthesis.
indent_func_proto_param         = false    # true/false

# Whether to indent continued function call declaration one indent level,
# rather than aligning parameters under the open parenthesis.
indent_func_class_param         = false    # true/false

# Whether to indent continued class variable constructors one indent level,
# rather than aligning parameters under the open parenthesis.
indent_func_ctor_var_param      = false    # true/false

# Whether to indent continued template parameter list one indent level,
# rather than aligning parameters under the open parenthesis.
indent_template_param           = true     # true/false

# Double the indent for indent_func_xxx_param options.
# Use both values of the options indent_columns and indent_param.
indent_func_param_double        = true     # true/false

# Whether to indent trailing single line ('//') comments relative to the code
# instead of trying to keep the same absolute column.
indent_relative_single_line_comments = false    # true/false

# Whether to indent comments found in first column.
indent_col1_comment             = true     # true/false

# How to indent access specifiers that are followed by a
# colon.
#
#  >0: Absolute column where 1 is the leftmost column
# <=0: Subtract from brace indent
#
# Default: 1
indent_access_spec              = -2       # number

# Whether to indent the code after an access specifier by one level.
# If true, this option forces 'indent_access_spec=0'.
indent_access_spec_body         = false    # true/false

# If an open parenthesis is followed by a newline, whether to indent the next
# line so that it lines up after the open parenthesis (not recommended).
indent_paren_nl                 = false    # true/false

# Whether to indent a comma when inside a parenthesis.
# If true, aligns under the open parenthesis.
indent_comma_paren              = false    # true/false

# Whether to indent a Boolean operator when inside a parenthesis.
# If true, aligns under the open parenthesis.
indent_bool_paren               = false    # true/false

# Whether to align the first expression to following ones
# if indent_bool_paren=true.
indent_first_bool_expr          = false    # true/false

# If an open square is followed by a newline, whether to indent the next line
# so that it lines up after the open square (not recommended).
indent_square_nl                = false    # true/false

# (ESQL/C) Whether to preserve the relative indent of 'EXEC SQL' bodies.
indent_preserve_sql             = false    # true/false

# Whether to align continued statements at the '='. If false or if the '=' is
# followed by a newline, the next line is indent one tab.
#
# Default: true
indent_align_assign             = true     # true/false

#
# Newline adding and removing options
#

# Whether to collapse empty blocks between '{' and '}'.
# If true, overrides nl_inside_empty_func
nl_collapse_empty_body          = true     # true/false

# Don't split one-line braced assignments, as in 'foo_t f = { 1, 2 };'.
nl_assign_leave_one_liners      = true     # true/false

# Don't split one-line braced statements inside a 'class xx { }' body.
nl_class_leave_one_liners       = true     # true/false

# Don't split one-line enums, as in 'enum foo { BAR = 15 };'
nl_enum_leave_one_liners        = true     # true/false

# Don't split one-line get or set functions.
nl_getset_leave_one_liners      = false    # true/false

# Don't split one-line function definitions, as in 'int foo() { return 0; }'.
# might modify nl_func_type_name
nl_func_leave_one_liners        = false    # true/false

# Don't split one-line if/else statements, as in 'if(...) b++;'.
nl_if_leave_one_liners          = false    # true/false

# Add or remove newline at the end of the file.
nl_end_of_file                  = force    # ignore/add/remove/force

# The minimum number of newlines at the end of the file (only used if
# nl_end_of_file is 'add' or 'force').
nl_end_of_file_min              = 1        # unsigned number

# Add a newline between ')' and '{' if the ')' is on a different line than the
# if/for/etc.
#
# Overrides nl_for_brace, nl_if_brace, nl_switch_brace, nl_while_switch and
# nl_catch_brace.
nl_multi_line_cond              = false    # true/false

# Force a newline in a define after the macro name for multi-line defines.
nl_multi_line_define            = false    # true/false

# Whether to add a newline before 'case', and a blank line before a 'case'
# statement that follows a ';' or '}'.
nl_before_case                  = false    # true/false

# Whether to add a newline after a 'case' statement.
nl_after_case                   = false    # true/false

# Whether to add a newline after semicolons, except in 'for' statements.
nl_after_semicolon              = false    # true/false

# Whether to add a newline after '{'. This also adds a newline before the
# matching '}'.
nl_after_brace_open             = false    # true/false

# Whether to add a newline between the open brace and a trailing single-line
# comment. Requires nl_after_brace_open=true.
nl_after_brace_open_cmt         = false    # true/false

# Whether to add a newline after a virtual brace open with a non-empty body.
# These occur in un-braced if/while/do/for statement bodies.
nl_after_vbrace_open            = false    # true/false

# Whether to add a newline after a virtual brace open with an empty body.
# These occur in un-braced if/while/do/for statement bodies.
nl_after_vbrace_open_empty      = false    # true/false

# Whether to add a newline after '}'. Does not apply if followed by a
# necessary ';'.
nl_after_brace_close            = false    # true/false

# Whether to add a newline after a virtual brace close,
# as in 'if (foo) a++; <here> return;'.
nl_after_vbrace_close           = false    # true/false

# Whether to alter newlines in '#define' macros.
nl_define_macro                 = false    # true/false

# Whether to remove blanks after '#ifxx' and '#elxx', or before '#elxx' and
# '#endif'. Does not affect top-level #ifdefs.
nl_squeeze_ifdef                = false    # true/false

# Add or remove blank line before 'if'.
nl_before_if                    = ignore   # ignore/add/remove/force

# Whether to put a blank line after 'return' statements, unless followed by a
# close brace.
nl_after_return                 = false    # true/false

# Whether to double-space commented-entries in 'struct'/'union'/'enum'.
nl_ds_struct_enum_cmt           = false    # true/false

# Whether to force a newline before '}' of a 'struct'/'union'/'enum'.
# (Lower priority than eat_blanks_before_close_brace.)
nl_ds_struct_enum_close_brace   = false    # true/false

# Whether to remove a newline in simple unbraced if statements, turning them
# into one-liners, as in 'if(b)\n i++;' => 'if(b) i++;'.
nl_create_if_one_liner          = false    # true/false

# Whether to remove a newline in simple unbraced for statements, turning them
# into one-liners, as in 'for (...)\n stmt;' => 'for (...) stmt;'.
nl_create_for_one_liner         = false    # true/false

# Whether to remove a newline in simple unbraced while statements, turning
# them into one-liners, as in 'while (expr)\n stmt;' => 'while (expr) stmt;'.
nl_create_while_one_liner       = false    # true/false

# Whether to force a newline after a multi-line comment.
nl_after_multiline_comment      = false    # true/false

# Whether to remove blank lines after '{'.
eat_blanks_after_open_brace     = false    # true/false

# Whether to remove blank lines before '}'.
eat_blanks_before_close_brace   = false    # true/false

#
# Line splitting options
#

# Whether to fully split long 'for' statements at semi-colons.
ls_for_split_full               = false    # true/false

# Whether to fully split long function prototypes/calls at commas.
# The option ls_code_width has priority over the option ls_func_split_full.
ls_func_split_full              = false    # true/false

#
# Code alignment options (not left column spaces/tabs)
#

# Whether to keep non-indenting tabs.
align_keep_tabs                 = false    # true/false

# Whether to use tabs for aligning.
align_with_tabs                 = false    # true/false

# Whether to bump out to the next tab when aligning.
align_on_tabstop                = false    # true/false

# Modern uncrustify doesn't seem to have this anymore
align_number_left               = false    # true/false


# Whether to align variable definitions in prototypes and functions.
align_func_params               = false    # true/false

# Whether to align parameters in single-line functions that have the same
# name. The function names must already be aligned with each other.
align_same_func_call_params     = false    # true/false

# Whether to align the colon in struct bit fields.
align_var_def_colon             = false    # true/false

# Whether to align any attribute after the variable name.
align_var_def_attribute         = false    # true/false

# Whether to align inline struct/enum/union variable definitions.
align_var_def_inline            = false    # true/false

# If aligning comments, whether to mix with comments after '}' and #endif with
# less than three spaces before the comment.
align_right_cmt_mix             = false    # true/false

# Whether to align function prototypes on the 'operator' keyword instead of
# what follows.
align_on_operator               = false    # true/false

# Whether to mix aligning prototype and variable declarations. If true,
# align_var_def_XXX options are used instead of align_func_proto_XXX options.
align_mix_var_proto             = false    # true/false

# Whether to align single-line functions with function prototypes.
# Uses align_func_proto_span.
align_single_line_func          = false    # true/false

# Whether to align the open brace of single-line functions.
# Requires align_single_line_func=true. Uses align_func_proto_span.
align_single_line_brace         = false    # true/false

# Whether to align macros wrapped with a backslash and a newline. This will
# not work right if the macro contains a multi-line comment.
align_nl_cont                   = false    # true/false

# Whether to align lines that start with '<<' with previous '<<'.
#
# Default: true
align_left_shift                = true     # true/false

# (OC) Whether to align parameters in an Objective-C '+' or '-' declaration
# on the ':'.
align_oc_decl_colon             = false    # true/false

#
# Comment modification options
#


# Whether to apply changes to multi-line comments, including cmt_width,
# keyword substitution and leading chars.
#
# Default: true
cmt_indent_multi                = true     # true/false

# Whether to group c-comments that look like they are in a block.
cmt_c_group                     = false    # true/false

# Whether to put an empty '/*' on the first line of the combined c-comment.
cmt_c_nl_start                  = false    # true/false

# Whether to add a newline before the closing '*/' of the combined c-comment.
cmt_c_nl_end                    = false    # true/false

# Whether to change cpp-comments into c-comments.
cmt_cpp_to_c                    = false    # true/false

# Whether to group cpp-comments that look like they are in a block. Only
# meaningful if cmt_cpp_to_c=true.
cmt_cpp_group                   = false    # true/false

# Whether to put an empty '/*' on the first line of the combined cpp-comment
# when converting to a c-comment.
#
# Requires cmt_cpp_to_c=true and cmt_cpp_group=true.
cmt_cpp_nl_start                = false    # true/false

# Whether to add a newline before the closing '*/' of the combined cpp-comment
# when converting to a c-comment.
#
# Requires cmt_cpp_to_c=true and cmt_cpp_group=true.
cmt_cpp_nl_end                  = false    # true/false

# Whether to put a star on subsequent comment lines.
cmt_star_cont                   = false    # true/false

# For multi-line comments with a '*' lead, remove leading spaces if the first
# and last lines of the comment are the same length.
#
# Default: true
cmt_multi_check_last            = true     # true/false

# Whether a comment should be inserted if a preprocessor is encountered when
# stepping backwards from a function name.
#
# Applies to cmt_insert_oc_msg_header, cmt_insert_func_header and
# cmt_insert_class_header.
cmt_insert_before_preproc       = false    # true/false

#
# Code modifying options (non-whitespace)
#

# Whether to enforce that all blocks of an 'if'/'else if'/'else' chain either
# have, or do not have, braces. If true, braces will be added if any block
# needs braces, and will only be removed if they can be removed from all
# blocks.
#
# Overrides mod_full_brace_if.
mod_full_brace_if_chain         = false    # true/false

# (Pawn) Whether to change optional semicolons to real semicolons.
mod_pawn_semicolon              = false    # true/false

# Whether to fully parenthesize Boolean expressions in 'while' and 'if'
# statement, as in 'if (a && b > c)' => 'if (a && (b > c))'.
mod_full_paren_if_bool          = false    # true/false

# Whether to remove superfluous semicolons.
mod_remove_extra_semicolon      = false    # true/false

# Whether to sort consecutive single-line 'import' statements.
mod_sort_import                 = false    # true/false

# (C#) Whether to sort consecutive single-line 'using' statements.
mod_sort_using                  = false    # true/false

# Whether to sort consecutive single-line '#include' statements (C/C++) and
# '#import' statements (Objective-C). Be aware that this has the potential to
# break your code if your includes/imports have ordering dependencies.
mod_sort_include                = false    # true/false

# Whether to move a 'break' that appears after a fully braced 'case' before
# the close brace, as in 'case X: { ... } break;' => 'case X: { ... break; }'.
mod_move_case_break             = false    # true/false

# Whether to remove a void 'return;' that appears as the last statement in a
# function.
mod_remove_empty_return         = false    # true/false

#
# Preprocessor options
#

# Whether to indent #if/#else/#endif at the brace level. If false, these are
# indented from column 1.
pp_indent_at_level              = false    # true/false

# Whether to indent the code between #region and #endregion.
pp_region_indent_code           = false    # true/false

# Whether to indent the code between #if, #else and #endif.
pp_if_indent_code               = false    # true/false

# Whether to indent '#define' at the brace level. If false, these are
# indented from column 1.
pp_define_at_level              = false    # true/false

